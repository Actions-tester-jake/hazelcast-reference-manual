<?xml version='1.0' encoding='UTF-8'?>
<!--
  ~ Copyright (c) 2008-2013, Hazelcast, Inc. All Rights Reserved.
  ~
  ~ Licensed under the Apache License, Version 2.0 (the "License");
  ~ you may not use this file except in compliance with the License.
  ~ You may obtain a copy of the License at
  ~
  ~ http://www.apache.org/licenses/LICENSE-2.0
  ~
  ~ Unless required by applicable law or agreed to in writing, software
  ~ distributed under the License is distributed on an "AS IS" BASIS,
  ~ WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  ~ See the License for the specific language governing permissions and
  ~ limitations under the License.
  -->

<sect1 xml:id="DataSerializable" version='5.0' xmlns='http://docbook.org/ns/docbook'
       xmlns:xi="http://www.w3.org/2001/XInclude"
       xmlns:xlink="http://www.w3.org/1999/xlink"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xsi:schemaLocation="http://docbook.org/ns/docbook http://www.docbook.org/xml/5.0/xsd/docbook.xsd
       http://www.w3.org/1999/xlink http://www.w3.org/1999/xlink.xsd">
    <title>Data Serializable</title>


    For a faster serialization of objects, Hazelcast recommends to implement
        <literal>com.hazelcast.nio.serialization.DataSerializable</literal>
        interface. Here is an example of a class implementing
        <literal>com.hazelcast.nio.serialization.DataSerializable</literal>
        interface.
        <programlisting language="java"><![CDATA[public class Address implements com.hazelcast.nio.serialization.DataSerializable {
    private String street;
    private int zipCode;
    private String city;
    private String state;

    public Address() {}

    //getters setters..

    public void writeData(DataOutput out) throws IOException {
        out.writeUTF(street);
        out.writeInt(zipCode);
        out.writeUTF(city);
        out.writeUTF(state);
    }

    public void readData (DataInput in) throws IOException {
        street    = in.readUTF();
        zipCode = in.readInt();
        city    = in.readUTF();
        state    = in.readUTF();
    }
}
]]></programlisting>
        Lets take a look at another example which is encapsulating a
        <literal>DataSerializable</literal>
        field.<programlisting language="java"><![CDATA[public class Employee implements com.hazelcast.nio.serialization.DataSerializable {
    private String firstName;
    private String lastName;
    private int age;
    private double salary;
    private Address address; //address itself is DataSerializable

    public Employee() {}

    //getters setters..

    public void writeData(DataOutput out) throws IOException {
        out.writeUTF(firstName);
        out.writeUTF(lastName);
        out.writeInt(age);
        out.writeDouble (salary);
        address.writeData (out);
    }

    public void readData (DataInput in) throws IOException {
        firstName = in.readUTF();
        lastName  = in.readUTF();
        age       = in.readInt();
        salary       = in.readDouble();
        address   = new Address();
        // since Address is DataSerializable let it read its own internal state
        address.readData (in);
    }
}
]]></programlisting>As you can see, since
        <literal>address</literal>
        field itself
        is<literal>DataSerializable</literal>, it is calling
        <literal>address.writeData(out)</literal>
        when writing and
        <literal>address.readData(in)</literal>
        when reading.
    </para>
    <para>
        <emphasis role="bold">Caution:</emphasis>
        Hazelcast serialization is done on the user
        thread and it assumes that there will be only one object serialization at a time. So
        putting any Hazelcast operation that will require to serialize anything else will
        break the serialization. For Example: Putting<programlisting language="java"><![CDATA[Hazelcast.getMap("anyMap").put("key", "dummy value");
]]></programlisting>line in readData or writeData methods will break the serialization. If you have
        to perform such an operation, at least it should be performed in another thread
        which will force the serialization to take on different thread.
    </para>
</sect1>
