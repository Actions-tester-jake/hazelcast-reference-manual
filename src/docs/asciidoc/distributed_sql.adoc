== SQL

SQL allows you to query data stored in `IMap` declaratively.

WARNING: The SQL feature is currently in beta. The compatibility between versions
is not guaranteed. API might change between versions without notice.

=== Example

Consider that we have an IMap `emp` that contains values of type `Employee`:

[source,java]
----
public class Employee implements Serializable {
    private String name;
    private int age;

    public Employee(String name, int age) {
        this.name = name;
        this.age = age;
    }

    public String getName() {
        return name;
    }

    public int getAge() {
        return age;
    }
}
----

The following code will print names of employees whose age is less than 30:

[source,java]
----
try (SqlResult result = hazelcastInstance.getSql().execute("SELECT name FROM emp WHERE age < ?", 30)) {
    for (SqlRow row : result) {
        String name = row.getObject(0);

        System.out.println(name);
    }
}
----

The same code snippet could be executed from a member or a client.

=== Querying IMap

==== Names

The SQL service exposes `IMap` objects as tables in the predefined `partitioned`
schema using exact names. This schema is in the SQL service search path so that
`IMap` objects could be accessed with or without the schema name.

Schema and table names are case sensitive. For example, the `IMap` with the name
`employee` can be accessed as `employee` or `partitioned.employee`, but not as
`Employee`.

==== Fields

The SQL service reads the first local entry of the `IMap` to get the list of fields
accessible from the SQL. The SQL service extracts field metadata (name, type)
from the key and the value, and combines them into a final list of fields.

Field metadata extraction logic depends on the serialization format, as described
below.

-  For Java objects (`Serializable`, `DataSerializable`, `IdentifiedDataSerializable`),
the object is deserialized if needed and then analyzed using reflection. Only public
fields and getters are taken in count. A public field is exposed using its exact name.
A getter is exposed using the JavaBean naming conventions. E.g. `getName` is exposed as
`name` and `isActive` is exposed as `active`
- For `Portable` objects, only the fields that are written in the `Portable.writePortable`
method are exposed using their exact names
- `HazelcastJsonValue` objects cannot be queried at the moment. This limitation will be
removed in future releases

Field names are case-sensitive.

If the `IMap` does not have local entries on the member where the query is started,
then the list of fields cannot be resolved, and an exception is thrown.

We refer to the key and the value as *top-level* objects. The key is exposed as
`__key` field, and the value is exposed as `this` field.

If a top-level object does not have nested fields, then it is exposed as a normal
field. Otherwise, it is exposed a *hidden field*. Hidden fields behave similarly
to normal fields, but are not returned by `SELECT * ...` queries.

If both the key and the value have fields with the same name, then the field of the
value will be used.

Consider the `Employee` class from the first example, that is stored in the `IMap<Long, Employee>`.
The following fields will be accessible from the SQL.

[cols="1,1,1", options="header"]
|===
| Name
| Type
| Note

|`__key`
|`BIGINT`
|The key object

|`this`
|`OBJECT`
|The value object (hidden)

|`name`
|`VARCHAR`
|

|`age`
|`INTEGER`
|

|===

==== Indexes

The SQL service could use `IMap` indexes to speed up the execution of certain queries.
`SORTED` and `HASH` indexes are supported.

See <<indexing-queries, Indexes>> for more information on `IMap`
index creation.

==== High-Density Memory Store

`IMap` objects with the `InMemoryFormat.NATIVE` could only be queried if they have
at least one index, and the system property `hazelcast.hd.global.index.enabled` is
set to `true` (default). Otherwise, an exception will be thrown.

See <<configuring-with-system-properties, Configuring with System Properties>> for
more information on setting system properties.

=== Data Types

The SQL service supports a set of SQL data types. Every data type is mapped to a Java
class that represents the type's value.

[cols="1,1", options="header"]
.SQL Data Types
|===
| Type Name
| Java Class

|`BOOLEAN`
|`java.lang.Boolean`

|`VARCHAR`
|`java.lang.String`

|`TINYINT`
|`java.lang.Byte`

|`SMALLINT`
|`java.lang.Short`

|`INTEGER`
|`java.lang.Integer`

|`BIGINT`
|`java.lang.Long`

|`DECIMAL`
|`java.math.BigDecimal`

|`REAL`
|`java.lang.Float`

|`DOUBLE`
|`java.lang.Double`

|`DATE`
|`java.time.LocalDate`

|`TIME`
|`java.time.LocalTime`

|`TIMESTAMP`
|`java.time.LocalDateTime`

|`TIMESTAMP_WITH_TIME_ZONE`
|`java.time.OffsetDateTime`

|`OBJECT`
|Any Java class

|===

=== Supported Features

Currently it is possible to execute project-filter queries in the form
`SELECT ... FROM <map_name> WHERE ...` on a single map.

The following features are *not supported* and are planned for future releases:
sorting, aggregations, joins, set operators (`UNION`, `INTERSECT`, `MINUS`), subqueries.

The SQL service supports the following functions:

- Binary functions: `+`, `-`, `*`, `/`
- Comparison predicates: `>`, `>=`, `<`, `<=`, `=`, `!=`, `<>`
- Logical predicates: `AND`, `OR`, `NOT`
- `IS` predicates: `IS [NOT] NULL`, `IS [NOT] TRUE`, `IS [NOT] FALSE`
- `CAST` function
- Math functions: `ABS`, `ACOS`, `ASIN`, `ATAN`, `CEIL`, `COS`, `COT`,
`DEGREES`, `EXP`, `FLOOR`, `LN`, `LOG10`, `RADIANS`, `RAND`, `ROUND`,
`SIGN`, `SIN`, `TAN`, `TRUNCATE`
- String functions: `||` (concatenation), `ASCII`, `INITCAP`, `LENGTH`,
`LIKE`, `LOWER`, `LTRIM`, `RTRIM`, `SUBSTRING`, `TRIM`, `UPPER`

=== Lite Members

SQL queries cannot be started on lite-members. This limitation will be removed in
future releases.

=== How Distributed SQL Works

When an SQL statement is submitted for execution, the SQL service parses and
optimizes it using Apache Calcite. The result is an executable plan that
is cached and reused by the subsequent executions of the same statement.

The plan contains a tree of query fragments. A query fragment is a tree of
operators that could be executed on a single member independently. Child
fragments supply data to parent fragments, possibly through a network, until
the root fragment is reached. The root fragment returns query results to a
user.
