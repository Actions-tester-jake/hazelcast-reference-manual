

== SQL

SQL allows you to query data stored in `IMap` declaratively.

WARNING: The SQL feature is currently in beta. The compatibility between versions
is not guaranteed. API might change between versions without notice.

=== Example

Consider that we have an IMap `emp` that contains values of type `Employee`:

[source,java]
----
public class Employee implements Serializable {
    private long id;
    private String name;
    private int age;
    private boolean active;
    private double salary;

    public Employee(long id, String name, int age, boolean active, double salary) {
        this.id = id;
        this.name = name;
        this.age = age;
        this.active = active;
        this.salary = salary;
    }

    public long getId() {
        return id;
    }

    public String getName() {
        return name;
    }

    public int getAge() {
        return age;
    }

    public double getSalary() {
        return salary;
    }

    public boolean isActive() {
        return active;
    }
}
----

The following code will print IDs of employees who are active and whose age
is less than 30:

[source,java]
----
try (SqlResult result = hazelcastInstance.getSql().execute("SELECT id FROM emp WHERE active AND age < ?", 30)) {
    for (SqlRow row : result) {
        long id = row.getObject(0);

        System.out.println(id);
    }
}
----

=== Querying IMap

==== Names

The SQL service exposes `IMap` objects as tables in the predefined `partitioned`
schema using exact names. This schema is in the SQL service search path so that
`IMap` objects could be accessed with or without the schema name.

Schema and table names are case sensitive. For example, the `IMap` with the name
`employee` can be accessed as `employee` or `partitioned.employee`, but not as
`Employee`.

==== Fields

The SQL service reads the first local entry of the `IMap` to get the list of fields
accessible from the SQL. The SQL service extracts field metadata (name, type)
from the key and the value, and combines them into a final list of fields.

Field metadata extraction logic depends on the serialization format, as described
below.

-  For Java objects (`Serializable`, `DataSerializable`, `IdentifiedDataSerializable`),
the object is deserialized if needed and then analyzed using reflection. Only public
fields and getters are taken in count. A public field is exposed using its exact name.
A getter is exposed using the JavaBean naming conventions. E.g. `getName` is exposed as
`name` and `isActive` is exposed as `active`
- For `Portable` objects, only the fields that are written in the `Portable.writePortable`
method are exposed using their exact names
- `HazelcastJsonValue` objects cannot be queried at the moment. This limitation will be
removed in future releases

Field names are case-sensitive.

If the `IMap` does not have local entries on the member where the query is started,
then the list of fields cannot be resolved, and an exception is thrown.

We refer to the key and the value as *top-level* objects. The key is exposed as
`__key` field, and the value is exposed as `this` field.

If a top-level object does not have nested fields, then it is exposed as a normal
field. Otherwise, it is exposed a *hidden field*. Hidden fields behave similarly
to normal fields, but are not returned by `SELECT * ...` queries.

If both the key and the value have fields with the same name, then the field of the
value will be used.

==== Indexes

The SQL service could use `IMap` indexes to speed up the execution of certain queries.
`SORTED` and `HASH` indexes are supported.

See <<indexing-queries, Indexes>> for more information on `IMap`
index creation.

==== High-Density Memory Store

`IMap` objects with the `InMemoryFormat.NATIVE` could only be queried if they have
at least one index, and the system property `hazelcast.hd.global.index.enabled` is
set to `true` (default). Otherwise, an exception will be thrown.

See <<configuring-with-system-properties, Configuring with System Properties>> for
more information on setting system properties.

=== Supported Features

==== Data Types

The following SQL types are currently supported.

General:

- `BOOLEAN` (`java.lang.Boolean`)
- `VARCHAR` (`java.lang.String`, `java.lang.Character`)
- `OBJECT`

Numeric:

- `TINYINT` (`java.lang.Byte`)
- `SMALLINT` (`java.lang.Short`)
- `INTEGER` (`java.lang.Integer`)
- `BIGINT` (`java.lang.Long`)
- `DECIMAL` (`java.math.BigDecimal`, `java.math.BigInteger`)
- `REAL` (`java.lang.Float`)
- `DOUBLE` (`java.lang.Double`)

Temporal:

- `DATE` (`java.time.LocalDate`)
- `TIME` (`java.time.LocalTime`)
- `TIMESTAMP` (`java.time.LocalDateTime`)
- `TIMESTAMP_WITH_TIME_ZONE` (`java.time.OffsetDateTime`, `java.time.ZonedDateTime`,
`java.time.Instant`, `java.util.Date`, `java.util.Calendar`)

==== Operators

It is possible to execute project-filter queries in the form
`SELECT ... FROM <map_name> WHERE ...` on a single map.

The support for the following operators are planned for future releases:

- `ORDER BY`
- `GROUP BY`
- Joins
- Set operators (`UNION`, `INTERSECT`, `MINUS`)
- Subqueries

==== Functions

The following functions are currently supported.

- Binary functions: `+`, `-`, `*`, `/`
- Comparison predicates: `>`, `>=`, `<`, `<=`, `=`, `!=`, `<>`
- Logical predicates: `AND`, `OR`, `NOT`
- `IS` predicates: `IS [NOT] NULL`, `IS [NOT] TRUE`, `IS [NOT] FALSE`
- `CAST` function
- Math functions: `ABS`, `ACOS`, `ASIN`, `ATAN`, `CEIL`, `COS`, `COT`,
`DEGREES`, `EXP`, `FLOOR`, `LN`, `LOG10`, `RADIANS`, `RAND`, `ROUND`,
`SIGN`, `SIN`, `TAN`, `TRUNCATE`
- String functions: `||` (concatenation), `ASCII`, `INITCAP`, `LENGTH`,
`LIKE`, `LOWER`, `LTRIM`, `RTRIM`, `SUBSTRING`, `TRIM`, `UPPER`

More functions will be added in future releases.

=== Clients

SQL queries could be executed from Java clients using the same API as with members.

The support for other client platforms is planned for future releases.

=== Lite Members

SQL queries cannot be started on lite-members. This limitation will be removed in
future releases.

=== How Distributed SQL Works

When an SQL statement is submitted for execution, the SQL service parses and
optimizes it using Apache Calcite. The result is an executable plan that
is cached and reused by the subsequent executions of the same statement.

The plan contains a tree of query fragments. A query fragment is a tree of
operators that could be executed on a single member independently. Child
fragments supply data to parent fragments, possibly through a network, until
the root fragment is reached. The root fragment returns query results to a
user.
