

## ICountDownLatch


CountdownLatch: Concurrent activity gate-keeping

The java.util.concurrent.CountDownLatch was introduced in Java 1.5 and is a syn- chronization aid that makes it possible for threads to wait until a set of operations, being performed by one or more threads to complete. Very simplistically; a Count- DownLatch could be seen as a gate containing a counter. Behind this gate, threads can wait till the counter reaches 0. In my experience CountDownLatches often are used when you have some kind of processing operation, and one or more threads need to wait till this operation completes so they can execute their logic. Hazelcast also contains a CountDownLatch; the org.hazelcast.core.ICountDownLatch.To explain the ICountDownLatch, imagine that there is a leader process that is executing some action and eventually completes. Also imagine that there are one or more follower processes that need to do something after the leader has completed. We can implement the behavior of the Leader:
public class Leader{public static void main(String[] args)throws Exception{HazelcastInstance hz = Hazelcast.newHazelcastInstance(); ICountDownLatch latch = hz.getCountDownLatch("latch"); System.out.println("Starting");latch.trySetCount(1);Thread.sleep(5000);latch.countDown(); System.out.println("Leader finished"); latch.destroy();} }
The Leader retrieves the CountDownLatch, calls ICountDownLatch.trySetCount on it which makes him owner of that latch, does some waiting and then calls countdown; which notifies the listeners for that latch. Currently we ignore the boolean return value of trySetCount since there will be only a single Leader, but in practice you probably want deal with the return value. Although there will only be a single owner of the Latch, the countDown method can be called by other threads/processes.The next part is the Follower:public class Follower {
public static void main(String[] args) throws Exception { HazelcastInstance hz = Hazelcast.newHazelcastInstance(); ICountDownLatch latch = hz.getCountDownLatch("latch"); System.out.println("Waiting");boolean success = latch.await(10, TimeUnit.SECONDS);System.out.println("Complete:"+success); }}
As you can see we first retrieve the ICountDownLatch and then call await on it so the thread listens for the ICountDownLatch to reach 0. In practice it can happen than a process that should have decremented the counter by calling the ICountDownLatch.countDown method, fails and therefore the ICountDownLatch will never reach 0. To force you to deal with this situation, there is no await method without a timeout to prevent waiting indefinitely.If we first start a leader and then one or more followers, the followers will wait till the leader completes. It is important that the leader is started first, else the followers will immediately complete since the latch already is 0. The example show a ICountDownLatch with only a single step. But if a process has n steps, initialize the ICountdownLatch with n instead of 1 and for each completed step call the countDown method.One thing to watch out for is that an ICountDownLatch waiter can be notified prematurely. In a distributed environment the leader could go down before it has reached zero and this would result in the waiters to wait till the end of time. Be- cause this behavior is undesirable, Hazelcast will automatically notify all listeners if the owner gets disconnected. So it can be that listeners are notified before all steps of a certain process are completed. To deal with this situation the current state of the process needs to be verified and appropriate actions need to be taken e.g. restart all operations, continue with the first failed operation, or throw an exception.Although the ICountDownLatch is a very useful synchronization aid, it probably isn’t one you will use on a daily basis. Unlike Java’s implementation, Hazelcast’s ICountDownLatch count can be re-set after a countdown has finished but not during an active count.
1. replication: the ICountDownLatch has 1 synchronous backup and zero asyn- cronous backups and is not configurable.
